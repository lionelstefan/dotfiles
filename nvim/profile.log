FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000010   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    1              0.000001   endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:93
Called 3 times
Total time:   0.003339
 Self time:   0.000281

count  total (s)   self (s)
   22              0.000028     for Fn in a:list
   22   0.003238   0.000180       let code = call(Fn, a:000)
   22              0.000024       if code != 0
    3              0.000003         return code
   19              0.000010       endif
   19              0.000011     endfor
                                return 0

FUNCTION  AirlineWebDevIcons()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-devicons/plugin/webdevicons.vim:590
Called 2 times
Total time:   0.000110
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000012   let w:airline_section_x = get(w:, 'airline_section_x', get(g:, 'airline_section_x', ''))
    2              0.000006   let w:airline_section_x .= ' %{WebDevIconsGetFileTypeSymbol()} '
    2   0.000077   0.000013   let hasFileFormatEncodingPart = airline#parts#ffenc() !=? ''
    2              0.000006   if g:webdevicons_enable_airline_statusline_fileformat_symbols && hasFileFormatEncodingPart
    2              0.000005     let w:airline_section_y = ' %{&fenc . " " . WebDevIconsGetFileFormatSymbol()} '
    2              0.000001   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:82
Called 39 times
Total time:   0.000173
 Self time:   0.000173

count  total (s)   self (s)
   39              0.000074   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   39              0.000014   endif
   39              0.000021   return ''

FUNCTION  airline#check_mode()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:217
Called 39 times
Total time:   0.032869
 Self time:   0.003407

count  total (s)   self (s)
   39              0.000085   if !has_key(s:contexts, a:winnr)
                                return ''
   39              0.000023   endif
   39              0.000084   let context = s:contexts[a:winnr]
                            
   39              0.000081   if get(w:, 'airline_active', 1)
   39              0.000072     let m = mode(1)
                                " Refer :help mode() to see the list of modes 
                                "   NB: 'let mode' here refers to the display colour _groups_, 
                                "   not the literal mode's code (i.e., m). E.g., Select modes
                                "   v, S and ^V use 'visual' since they are of similar ilk.
                                "   Some modes do not get recognised for status line purposes: 
                                "   no, nov, noV, no^V, !, cv, and ce.
                                "   Mode name displayed is handled in init.vim (g:airline_mode_map). 
                                " 
   39              0.000066     if m[0] ==# "i"
                                  let mode = ['insert']  " Insert modes + submodes (i, ic, ix)
   39              0.000053     elseif m[0] == "R"  
                                  let mode = ['replace']  " Replace modes + submodes (R, Rc, Rv, Rx) (NB: case sensitive as 'r' is a mode)
   39              0.000230     elseif m[0] =~ '\v(v|V||s|S|)'
                                    let mode = ['visual']  " Visual and Select modes (v, V, ^V, s, S, ^S))
   39              0.000032     elseif m ==# "t"  
                                  let mode = ['terminal']  " Terminal mode (only has one mode (t))
   39              0.000109     elseif m[0] =~ '\v(c|r|!)'
   25              0.000047       let mode = ['commandline']  " c, cv, ce, r, rm, r? (NB: cv and ce stay showing as mode entered from)
   14              0.000005     else
   14              0.000028       let mode = ['normal']  " Normal mode + submodes (n, niI, niR, niV; plus operator pendings no, nov, noV, no^V)
   39              0.000015     endif
   39              0.000115     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
   39              0.000013     endif
                                " Adjust to handle additional modes, which don't display correctly otherwise 
   39              0.000183     if index(['niI', 'niR', 'niV', 'ic', 'ix', 'Rc', 'Rv', 'Rx', 'multi'], m) == -1
   39              0.000045       let m = m[0]
   39              0.000015     endif
   39              0.000137     let w:airline_current_mode = get(g:airline_mode_map, m, m)
                              else
                                let mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
   39              0.000015   endif
                            
   39              0.000082   if g:airline_detect_modified && &modified
                                call add(mode, 'modified')
   39              0.000014   endif
                            
   39              0.000045   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
   39              0.000013   endif
                            
   39              0.000233   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
   39              0.000013   endif
                            
   39              0.000052   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
   39              0.000012   endif
                            
   39              0.000043   if &readonly || ! &modifiable
                                call add(mode, 'readonly')
   39              0.000013   endif
                            
   39              0.000103   let mode_string = join(mode)
   39              0.000093   if get(w:, 'airline_lastmode', '') != mode_string
    6   0.001453   0.000043     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    6   0.027859   0.000051     call airline#highlighter#highlight(mode, string(context.bufnr))
    6   0.000278   0.000034     call airline#util#doautocmd('AirlineModeChanged')
    6              0.000009     let w:airline_lastmode = mode_string
   39              0.000012   endif
                            
   39              0.000024   return ''

FUNCTION  <SNR>120_get_section()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/default.vim:20
Called 28 times
Total time:   0.001125
 Self time:   0.000891

count  total (s)   self (s)
   28              0.000065   if has_key(s:section_truncate_width, a:key)
   19   0.000299   0.000142     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
    3              0.000003       return ''
   16              0.000006     endif
   25              0.000010   endif
   25              0.000041   let spc = g:airline_symbols.space
   25              0.000081   if !exists('g:airline_section_{a:key}')
                                return ''
   25              0.000010   endif
   25   0.000282   0.000206   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   25              0.000152   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   25              0.000081   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#util#append()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:49
Called 273 times
Total time:   0.002000
 Self time:   0.002000

count  total (s)   self (s)
  273              0.000450   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  273              0.000086   endif
  273              0.000583   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  273              0.000611   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:216
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    2              0.000008   let dt = localtime() - s:focusgained_ignore_time
    2              0.000004   let s:focusgained_ignore_time = 0
    2              0.000003   return dt >= 1

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:190
Called 39 times
Total time:   0.000400
 Self time:   0.000400

count  total (s)   self (s)
   39              0.000107   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
   39              0.000139   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
   39              0.000014   endif

FUNCTION  <SNR>79_DevIconsGetArtifactFix()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-devicons/plugin/webdevicons.vim:554
Called 103 times
Total time:   0.000551
 Self time:   0.000551

count  total (s)   self (s)
  103              0.000133   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
  103              0.000034   else
  103              0.000094     let artifactFix = ''
  103              0.000038   endif
                            
  103              0.000082   return artifactFix

FUNCTION  gutentags#find_job_index_by_tags_file()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-gutentags/autoload/gutentags.vim:373
Called 39 times
Total time:   0.000327
 Self time:   0.000327

count  total (s)   self (s)
   39              0.000043     let l:idx = -1
   39              0.000086     for upd_info in s:update_in_progress[a:module]
                                    let l:idx += 1
                                    if upd_info[0] == a:tags_file
                                        return l:idx
                                    endif
   39              0.000024     endfor
   39              0.000023     return -1

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/themes.vim:35
Called 100 times
Total time:   0.012553
 Self time:   0.000735

count  total (s)   self (s)
  100   0.012526   0.000707     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  FugitiveWorkTree()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:310
Called 39 times
Total time:   0.002055
 Self time:   0.000378

count  total (s)   self (s)
   39   0.001958   0.000281   let tree = s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
   39              0.000046   if tree isnot# 0 || a:0 > 1
   39              0.000029     return tree
                              else
                                return ''
                              endif

FUNCTION  <SNR>125_initialize_job()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:450
Called 4 times
Total time:   0.000413
 Self time:   0.000048

count  total (s)   self (s)
    4   0.000411   0.000046   return s:wrap_cmd(a:bufnr, a:vcs, s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds))

FUNCTION  <SNR>73_on_focus_gained()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/plugin/airline.vim:77
Called 2 times
Total time:   0.026024
 Self time:   0.000039

count  total (s)   self (s)
    2   0.000032   0.000013   if airline#util#try_focusgained()
    2   0.025988   0.000023     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    2              0.000001   endif

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 78 times
Total time:   0.005009
 Self time:   0.005009

count  total (s)   self (s)
   78              0.004898   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
   78              0.000064     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.diagnostic')")
                                let severity = a:type == 'Warning' ? 'Warn' : a:type
                                let num = len(v:lua.vim.diagnostic.get(0, { 'severity': severity }))
                              elseif luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:255
Called 6 times
Total time:   0.027808
 Self time:   0.003969

count  total (s)   self (s)
    6              0.000010     let bufnr = a:0 ? a:1 : ''
    6              0.000014     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
    6              0.000029     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    6              0.000012     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    6              0.000008     let airline_grouplist = []
    6              0.000018     let buffers_in_tabpage = sort(tabpagebuflist())
    6              0.000009     if exists("*uniq")
    6              0.000011       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    6              0.000002     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
   12              0.000015     for mode in reverse(mapped)
    6              0.000019       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    3              0.000007         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   63              0.000069         for kvp in items(dict)
   60              0.000073           let mode_colors = kvp[1]
   60              0.000066           let name = kvp[0]
   60              0.000124           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                        let name = 'airline_c'.bufnr
   60              0.000020           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
   60              0.000182           if name =~# 'airline_c\d\+'
    3              0.000017             let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
    3              0.000015             if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
    3              0.000002               continue
                                        endif
   57              0.000202           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
   30              0.000016             continue
   27              0.000009           endif
   27   0.000250   0.000126           if s:group_not_done(airline_grouplist, name.suffix)
   27   0.005120   0.000131             call airline#highlighter#exec(name.suffix, mode_colors)
   27              0.000010           endif
                            
   27              0.000039           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
   27              0.000010           endif
                            
   54              0.000068           for accent in keys(s:accents)
   27              0.000042             if !has_key(p.accents, accent)
                                          continue
   27              0.000009             endif
   27              0.000056             let colors = copy(mode_colors)
   27              0.000044             if p.accents[accent][0] != ''
                                          let colors[0] = p.accents[accent][0]
   27              0.000009             endif
   27              0.000039             if p.accents[accent][2] != ''
                                          let colors[2] = p.accents[accent][2]
   27              0.000009             endif
   27              0.000032             if len(colors) >= 5
   27              0.000068               let colors[4] = get(p.accents[accent], 4, '')
                                        else
                                          call add(colors, get(p.accents[accent], 4, ''))
   27              0.000009             endif
   27   0.000261   0.000146             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   27   0.005062   0.000144               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   27              0.000010             endif
   54              0.000023           endfor
   30              0.000012         endfor
                            
    3              0.000004         if empty(s:separators)
                                      " nothing to be done
                                      continue
    3              0.000001         endif
                                    " TODO: optimize this
   36              0.000038         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
   33   0.013928   0.000235           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   36              0.000015         endfor
    6              0.000003       endif
   12              0.000010     endfor

FUNCTION  <SNR>96_CheckDefined()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:108
Called 110 times
Total time:   0.001727
 Self time:   0.001727

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
  110              0.000230     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  110              0.000040     endif
  110              0.000262     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                  return a:colors
  110              0.000038     endif
                            
  110              0.000152     for val in a:colors
  110              0.000274       if !empty(val) && val !=# 'NONE'
  110              0.000088         return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:143
Called 39 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
   39              0.000068   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
   39              0.000013   endif
   39              0.000031   return s:has_fugitive

FUNCTION  fugitive#DidChange()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:4216
Called 2 times
Total time:   0.000104
 Self time:   0.000066

count  total (s)   self (s)
    2   0.000042   0.000017   call s:ExpireStatus(a:0 ? a:1 : -1)
    2              0.000006   if a:0 > 1 ? a:2 : (!a:0 || a:1 isnot# 0)
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
    2              0.000001   else
    2   0.000026   0.000013     call s:ReloadWinStatus()
    2              0.000002     return ''
                              endif
                              exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                              return ''

FUNCTION  airline#parts#filetype()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:102
Called 39 times
Total time:   0.000508
 Self time:   0.000282

count  total (s)   self (s)
   39   0.000488   0.000263   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 2 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000006   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    2              0.000001   endif

FUNCTION  airline#extensions#tabline#formatters#unique_tail#format()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/tabline/formatters/unique_tail.vim:6
Called 25 times
Total time:   0.002280
 Self time:   0.001815

count  total (s)   self (s)
   25              0.000036   let duplicates = {}
   25              0.000024   let tails = {}
   25              0.000023   let map = {}
   50              0.000051   for nr in a:buffers
   25              0.000049     let name = bufname(nr)
   25              0.000034     if empty(name)
                                  let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, '[No Name]')
   25              0.000011     else
   25              0.000126       if name =~ 'term://'
                                    " Neovim Terminal
                                    let tail = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
   25              0.000009       else
   25              0.000116         let tail = fnamemodify(name, ':s?/\+$??:t')
   25              0.000016       endif
   25              0.000044       if has_key(tails, tail)
                                    let duplicates[nr] = nr
   25              0.000009       endif
   25              0.000043       let tails[tail] = 1
   25   0.000651   0.000186       let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, tail)
   25              0.000010     endif
   50              0.000029   endfor
                            
   25              0.000058   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':p:.')
   25              0.000059   for nr in values(duplicates)
                                let name = bufname(nr)
                                let fnamecollapse = get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                if fnamecollapse
                                  let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g'))
                                else
                                  let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, fnamemodify(name, fmod))
                                endif
   25              0.000013   endfor
                            
   25              0.000040   if has_key(map, a:bufnr)
   25              0.000039     return map[a:bufnr]
                              endif
                            
                              " if we get here, the buffer list isn't in sync with the selected buffer yet, fall back to the default
                              return airline#extensions#tabline#formatters#default#format(a:bufnr, a:buffers)

FUNCTION  <SNR>125_replace()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:531
Called 12 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   12              0.000048   let parts = split(a:cmd, a:pat, 1)
   12              0.000028   return join(parts, a:sub)

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/term.vim:14
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000010   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    2              0.000001   endif

FUNCTION  <SNR>136_Slash()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:146
Called 39 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
   39              0.000037     return a:path

FUNCTION  sy#verbose()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:119
Called 20 times
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
   20              0.000032   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
   20              0.000008   endif

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/tabline/buflist.vim:39
Called 25 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   25              0.000051   if exists('s:current_buffer_list')
   25              0.000023     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  airline#mode_changed()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:297
Called 6 times
Total time:   0.000084
 Self time:   0.000060

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    6              0.000033   let g:airline#visual_active = (mode() =~? '[vs]')
    6   0.000044   0.000020   call airline#update_tabline()

FUNCTION  18()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:62
Called 3 times
Total time:   0.021589
 Self time:   0.002418

count  total (s)   self (s)
    3              0.000004   let side = 1
    3              0.000003   let line = ''
    3              0.000003   let i = 0
    3              0.000008   let length = len(self._sections)
    3              0.000004   let split = 0
    3              0.000004   let is_empty = 0
    3              0.000004   let prev_group = ''
                            
   26              0.000054   while i < length
   23              0.000054     let section = self._sections[i]
   23              0.000044     let group = section[0]
   23              0.000043     let contents = section[1]
   23              0.000034     let pgroup = prev_group
   23   0.000443   0.000191     let prev_group = airline#builder#get_prev_group(self._sections, i)
   23              0.000072     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   23              0.000087     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   23              0.000088     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   23              0.000013     endif
   23              0.000022     if is_empty
                                  let prev_group = pgroup
   23              0.000011     endif
   23   0.000417   0.000168     let is_empty = s:section_is_empty(self, contents)
                            
   23              0.000019     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   23              0.000010     endif
                            
   23              0.000028     if group == ''
                                  let line .= contents
   23              0.000028     elseif group == '|'
    3              0.000003       let side = 0
    3              0.000007       let line .= contents
    3              0.000003       let split = 1
   20              0.000011     else
   20              0.000026       if prev_group == ''
    3              0.000008         let line .= '%#'.group.'#'
   17              0.000017       elseif split
    3              0.000003         if !is_empty
    3   0.002152   0.000030           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    3              0.000002         endif
    3              0.000003         let split = 0
   14              0.000007       else
   14              0.000014         if !is_empty
   14   0.015697   0.000186           let line .= s:get_seperator(self, prev_group, group, side)
   14              0.000009         endif
   20              0.000011       endif
   20   0.001307   0.000271       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   23              0.000012     endif
                            
   23              0.000036     let i = i + 1
   26              0.000022   endwhile
                            
    3              0.000004   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    1              0.000033     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    3              0.000002   endif
    3              0.000008   return line

FUNCTION  <SNR>125_handle_diff()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:117
Called 4 times
Total time:   0.001692
 Self time:   0.000285

count  total (s)   self (s)
    4   0.000082   0.000024   call sy#verbose('s:handle_diff()', a:options.vcs)
                            
    4              0.000008   if has_key(a:options, 'tempfiles')
                                for f in a:options.tempfiles
                                  call delete(f)
                                endfor
    4              0.000002   endif
                            
    4              0.000013   let sy = getbufvar(a:options.bufnr, 'sy')
    4              0.000005   if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
    4              0.000014   elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
    4              0.000005   elseif empty(sy.vcs)
                                let g:signify_detecting -= 1
                                let sy.detecting -= 1
    4              0.000002   endif
                            
    4              0.000020   let fenc = getbufvar(a:options.bufnr, '&fenc')
    4              0.000013   let enc  = getbufvar(a:options.bufnr, '&enc')
    4              0.000008   if (fenc != enc) && has('iconv')
                                call map(a:options.stdoutbuf, printf('iconv(v:val, "%s", "%s")', fenc, enc))
    4              0.000002   endif
                            
    4   0.000047   0.000036   let [found_diff, diff] = s:check_diff_{a:options.difftool}(a:exitval, a:options.stdoutbuf)
    4              0.000003   if found_diff
    4              0.000009     if index(sy.vcs, a:options.vcs) == -1
                                  let sy.vcs += [a:options.vcs]
    4              0.000002     endif
    4   0.001360   0.000021     call a:options.func(sy, a:options.vcs, diff)
                              else
                                call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
    4              0.000001   endif
                            
    4              0.000012   call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:184
Called 17 times
Total time:   0.011562
 Self time:   0.000284

count  total (s)   self (s)
   17              0.000105     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   17   0.011447   0.000169     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/po.vim:64
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000006   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * call s:autocmd_handler()
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    2              0.000001   endif

FUNCTION  airline#extensions#tabline#formatters#webdevicons#format()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-devicons/autoload/airline/extensions/tabline/formatters/webdevicons.vim:6
Called 25 times
Total time:   0.005805
 Self time:   0.000485

count  total (s)   self (s)
                              " Call original formatter.
   25   0.002518   0.000238   let originalFormatter = airline#extensions#tabline#formatters#{g:_webdevicons_airline_orig_formatter}#format(a:bufnr, a:buffers)
   25   0.003261   0.000221   return originalFormatter . g:WebDevIconsTabAirLineBeforeGlyphPadding . WebDevIconsGetFileTypeSymbol(bufname(a:bufnr)) . g:WebDevIconsTabAirLineAfterGlyphPadding

FUNCTION  <SNR>91_check_defined_section()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:48
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000008   if !exists('w:airline_section_{a:name}')
                                let w:airline_section_{a:name} = g:airline_section_{a:name}
    2              0.000001   endif

FUNCTION  <SNR>120_add_section()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/default.vim:47
Called 19 times
Total time:   0.001583
 Self time:   0.000581

count  total (s)   self (s)
   19              0.000094     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   19   0.000288   0.000108     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   19              0.000009     endif
   19              0.000016     if condition
                                  call a:builder.add_raw('%(')
   19              0.000009     endif
   19   0.001024   0.000203     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   19              0.000017     if condition
                                  call a:builder.add_raw('%)')
   19              0.000019     endif

FUNCTION  airline#util#winwidth()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:19
Called 448 times
Total time:   0.002696
 Self time:   0.002696

count  total (s)   self (s)
  448              0.000780   let nr = get(a:000, 0, 0)
  448              0.000705   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  448              0.000154   else
  448              0.000551     return winwidth(nr)
                              endif

FUNCTION  sy#sign#get_current_signs()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:27
Called 4 times
Total time:   0.000233
 Self time:   0.000120

count  total (s)   self (s)
    4              0.000005   let a:sy.internal = {}
    4              0.000005   let a:sy.external = {}
                            
    4   0.000133   0.000021   let signlist = sy#util#execute('sign place buffer='. a:sy.buffer)
                            
    4              0.000020   for signline in split(signlist, '\n')[2:]
                                let tokens = matchlist(signline, '\v^\s+\S+\=(\d+)\s+\S+\=(\d+)\s+\S+\=(.*)$')
                                let line   = str2nr(tokens[1])
                                let id     = str2nr(tokens[2])
                                let type   = tokens[3]
                            
                                if type =~# '^Signify'
                                  " Handle ambiguous signs. Assume you have signs on line 3 and 4.
                                  " Removing line 3 would lead to the second sign to be shifted up
                                  " to line 3. Now there are still 2 signs, both one line 3.
                                  if has_key(a:sy.internal, line)
                                    execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
                                  endif
                                  let a:sy.internal[line] = { 'type': type, 'id': id }
                                else
                                  let a:sy.external[line] = id
                                endif
    4              0.000003   endfor

FUNCTION  airline#util#doautocmd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:176
Called 8 times
Total time:   0.000359
 Self time:   0.000098

count  total (s)   self (s)
    8              0.000021   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
    8              0.000003   endif
    8   0.000324   0.000063   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>136_ReloadWinStatus()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:4175
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000010   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    2              0.000002     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/nvimlsp.vim:41
Called 39 times
Total time:   0.003478
 Self time:   0.000202

count  total (s)   self (s)
   39   0.003459   0.000184   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/tabline.vim:228
Called 25 times
Total time:   0.006319
 Self time:   0.000426

count  total (s)   self (s)
   25   0.000234   0.000147     let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   25              0.000076     let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   25   0.005996   0.000191     return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 39 times
Total time:   0.001043
 Self time:   0.001043

count  total (s)   self (s)
   39              0.000160   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   39              0.000108     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   39              0.000120     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   39              0.000082     let default = get(g:, 'airline#extensions#keymap#default', '')
   39              0.000041     if (label !=# '')
   39              0.000051       let label .= ' '
   39              0.000015     endif
   39              0.000048     let keymap = &keymap
   39              0.000064     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   39              0.000014     endif
   39              0.000213     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  11()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:8
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000010   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/default.vim:79
Called 3 times
Total time:   0.002283
 Self time:   0.000196

count  total (s)   self (s)
    3              0.000006   let winnr = a:context.winnr
    3              0.000005   let active = a:context.active
                            
    3   0.000036   0.000025   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    2   0.000531   0.000014     call s:build_sections(a:builder, a:context, s:layout[0])
    1              0.000001   else
    1   0.000105   0.000016     let text = !empty(s:get_section(winnr, 'c')) ? s:get_section(winnr, 'c') : ' %f%m '
    1   0.000023   0.000018     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    3              0.000001   endif
                            
    3   0.000155   0.000041   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    3   0.000025   0.000017   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    3   0.001366   0.000021     call s:build_sections(a:builder, a:context, s:layout[1])
    3              0.000002   endif
                            
    3              0.000003   return 1

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:189
Called 5 times
Total time:   0.000174
 Self time:   0.000124

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
    5   0.000167   0.000117   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  <SNR>119_section_is_empty()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:182
Called 23 times
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
   23              0.000028   let start=1
                            
                              " do not check for inactive windows or the tabline
   23              0.000035   if a:self._context.active == 0
    5              0.000006     return 0
   18              0.000043   elseif get(a:self._context, 'tabline', 0)
                                return 0
   18              0.000009   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   18              0.000043   if get(g:, 'airline_skip_empty_sections', 0) == 0
   18              0.000013     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                            
                              if empty(a:content)
                                return 1
                              endif
                            
                              let stripped = substitute(a:content, '\(%{.*}\|%#__accent_[^#]*#\|%#__restore__#\|%( \| %)\)', '', 'g')
                            
                              if !empty(stripped)
                                return 0 " There is content in the statusline
                              endif
                            
                              let exprlist = []
                              call substitute(a:content, '%{\([^}]*\)}', '\=add(exprlist, submatch(1))', 'g')
                            
                              for expr in exprlist
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                              endfor
                              return 1

FUNCTION  <SNR>79_getDistro()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-devicons/plugin/webdevicons.vim:96
Called 39 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
   39              0.000053   if exists('s:distro')
   39              0.000029     return s:distro
                              endif
                            
                              if has('bsd')
                                let s:distro = 'ïŒŒ'
                                return s:distro
                              endif
                            
                              if g:DevIconsEnableDistro && executable('lsb_release')
                                let s:lsb = system('lsb_release -i')
                                if s:lsb =~# 'Arch'
                                  let s:distro = 'ïŒƒ'
                                elseif s:lsb =~# 'Gentoo'
                                  let s:distro = 'ïŒ'
                                elseif s:lsb =~# 'Ubuntu'
                                  let s:distro = 'îœº'
                                elseif s:lsb =~# 'Cent'
                                  let s:distro = 'ïŒ„'
                                elseif s:lsb =~# 'Debian'
                                  let s:distro = 'ïŒ†'
                                elseif s:lsb =~# 'Dock'
                                  let s:distro = 'ïŒˆ'
                                else
                                  let s:distro = 'îœ’'
                                endif
                                return s:distro
                              endif
                            
                              let s:distro = 'îœ’'
                              return s:distro

FUNCTION  FugitiveVimPath()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:495
Called 39 times
Total time:   0.000190
 Self time:   0.000190

count  total (s)   self (s)
   39              0.000074   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
   39              0.000015   else
   39              0.000030     return a:path
                              endif

FUNCTION  <SNR>119_get_transitioned_seperator()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:140
Called 17 times
Total time:   0.012596
 Self time:   0.001034

count  total (s)   self (s)
   17              0.000022   let line = ''
   17              0.000099   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   17              0.000009   else
   17   0.011712   0.000149     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   17              0.000276     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   17              0.000226     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   17              0.000068     let line .= '%#'.a:group.'#'
   17              0.000012   endif
   17              0.000020   return line

FUNCTION  airline#util#wrap()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:42
Called 273 times
Total time:   0.001672
 Self time:   0.001225

count  total (s)   self (s)
  273   0.001132   0.000685   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  273              0.000094   endif
  273              0.000196   return a:text

FUNCTION  FugitiveGitDir()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:18
Called 195 times
Total time:   0.006797
 Self time:   0.006644

count  total (s)   self (s)
  195              0.000182   if v:version < 703
                                return ''
  195              0.000722   elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
   39              0.000058     if exists('g:fugitive_event')
                                  return g:fugitive_event
   39              0.000014     endif
   39              0.000083     let dir = get(b:, 'git_dir', '')
   39              0.000131     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   39              0.000273     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                  return b:git_dir
   39              0.000014     endif
   39              0.000151     return dir =~# s:bad_git_dir ? '' : dir
  156              0.000286   elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
  156              0.000233   elseif type(a:1) == type('')
  156   0.001057   0.000904     return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'git_dir', '')
                              else
                                return ''
                              endif

FUNCTION  sy#start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:7
Called 4 times
Total time:   0.005282
 Self time:   0.000525

count  total (s)   self (s)
    4              0.000005   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
    4              0.000002   endif
                            
    4              0.000007   if g:signify_detecting > 50
                                call sy#verbose('Too many detection jobs running, deferring detection')
                                return
    4              0.000002   endif
                            
    4              0.000021   let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
    4              0.000010   let sy = getbufvar(bufnr, 'sy')
                            
    4              0.000005   if empty(sy)
                                let path = s:get_path(bufnr)
                                if s:skip(bufnr, path)
                                  call sy#verbose('Skip file: '. path)
                                  return
                                endif
                                call sy#verbose('Register new file: '. path)
                                let new_sy = { 'path':       path, 'buffer':     bufnr, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(path, ':p:h'),    'path': sy#util#escape(path),    'file': sy#util#escape(fnamemodify(path, ':t')) }}
                                call setbufvar(bufnr, 'sy', new_sy)
                                call sy#set_buflocal_autocmds(bufnr)
                                call sy#repo#detect(bufnr)
    4              0.000020   elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
    4              0.000002   else
    4   0.000146   0.000025     let path = s:get_path(bufnr)
    4              0.000021     if !filereadable(path)
                                  call sy#stop()
                                  return
    4              0.000008     elseif empty(sy.vcs)
                                  if get(sy, 'retry')
                                    let sy.retry = 0
                                    call sy#verbose('Redetecting VCS.')
                                    call sy#repo#detect(sy.buffer)
                                  else
                                    if get(sy, 'detecting')
                                      call sy#verbose('Detection is already in progress.')
                                    else
                                      call sy#verbose('No VCS found. Disabling.')
                                      call sy#stop(sy.buffer)
                                    endif
                                  endif
    4              0.000002     else
    8              0.000015       for vcs in sy.vcs
    4              0.000015         let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
    4              0.000011         if type(job_id) != type(0) || job_id > 0
                                      call sy#verbose('Update is already in progress.', vcs)
    4              0.000002         else
    4   0.000074   0.000021           call sy#verbose('Updating signs.', vcs)
    4   0.004628   0.000046           call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
    4              0.000004         endif
    8              0.000008       endfor
    4              0.000002     endif
    4              0.000002   endif

FUNCTION  gutentags#statusline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-gutentags/autoload/gutentags.vim:676
Called 39 times
Total time:   0.001628
 Self time:   0.000269

count  total (s)   self (s)
   39   0.001523   0.000164     let l:modules_in_progress = gutentags#inprogress()
   39              0.000051     if empty(l:modules_in_progress)
   39              0.000025        return ''
                                endif
                            
                                let l:prefix = ''
                                let l:suffix = ''
                                if a:0 > 0
                                   let l:prefix = a:1
                                endif
                                if a:0 > 1
                                   let l:suffix = a:2
                                endif
                            
                                if a:0 > 2
                                   let l:genmsg = a:3
                                else
                                   let l:genmsg = join(l:modules_in_progress, ',')
                                endif
                            
                                return l:prefix.l:genmsg.l:suffix

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/tabline.vim:169
Called 25 times
Total time:   0.004901
 Self time:   0.001127

count  total (s)   self (s)
   25              0.000184     let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   25              0.000061     let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   25              0.000053     let curtabcnt = tabpagenr('$')
   25              0.000075     if curtabcnt != s:current_tabcnt
                                  let s:current_tabcnt = curtabcnt
                                  call airline#extensions#tabline#tabs#invalidate()
                                  call airline#extensions#tabline#buffers#invalidate()
                                  call airline#extensions#tabline#ctrlspace#invalidate()
                                  call airline#extensions#tabline#tabws#invalidate()
   25              0.000017     endif
                            
   25              0.000069     if !exists('#airline#BufAdd#*')
                                  autocmd airline BufAdd * call <sid>update_tabline(0)
   25              0.000010     endif
   25              0.000057     if !exists('#airline#SessionLoadPost')
                                  autocmd airline SessionLoadPost * call <sid>update_tabline(1)
   25              0.000007     endif
   25              0.000019     if s:ctrlspace
                                  return airline#extensions#tabline#ctrlspace#get()
   25              0.000022     elseif s:tabws
                                  return airline#extensions#tabline#tabws#get()
   25              0.000041     elseif show_buffers && curtabcnt == 1 || !show_tabs
   25   0.003959   0.000185       return airline#extensions#tabline#buffers#get()
                                else
                                  return airline#extensions#tabline#tabs#get()
                                endif

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/term.vim:26
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000005   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    1              0.000000   endif

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:37
Called 23 times
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
   23              0.000038   let x = a:i - 1
   26              0.000030   while x >= 0
   23              0.000055     let group = a:sections[x][0]
   23              0.000048     if group != '' && group != '|'
   20              0.000021       return group
    3              0.000002     endif
    3              0.000004     let x = x - 1
    6              0.000004   endwhile
    3              0.000003   return ''

FUNCTION  <SNR>119_get_accented_line()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:163
Called 20 times
Total time:   0.001036
 Self time:   0.001036

count  total (s)   self (s)
   20              0.000032   if a:self._context.active
                                " active window
   16              0.000024     let contents = []
   16              0.000108     let content_parts = split(a:contents, '__accent')
   42              0.000056     for cpart in content_parts
   26              0.000159       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   26              0.000065       call add(contents, cpart)
   42              0.000029     endfor
   16              0.000064     let line = join(contents, a:group)
   16              0.000098     let line = substitute(line, '__restore__', a:group, 'g')
    4              0.000003   else
                                " inactive window
    4              0.000051     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
    4              0.000025     let line = substitute(line, '%#__restore__#', '', 'g')
   20              0.000011   endif
   20              0.000025   return line

FUNCTION  airline#util#getwinvar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:82
Called 41 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
   41              0.000117     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 39 times
Total time:   0.004471
 Self time:   0.003754

count  total (s)   self (s)
   39              0.000116   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   39              0.000204   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   39              0.000013   endif
   39              0.000267   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   39              0.000077   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
   39              0.000013   endif
   39   0.000892   0.000176   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>96_group_not_done()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:32
Called 54 times
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
   54              0.000100     if index(a:list, a:name) == -1
   54              0.000084       call add(a:list, a:name)
   54              0.000034       return 1
                                else
                                  if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
                                  endif
                                  return 0
                                endif

FUNCTION  airline#util#prepend()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:63
Called 195 times
Total time:   0.001018
 Self time:   0.001018

count  total (s)   self (s)
  195              0.000338   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  195              0.000063   endif
  195              0.000432   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  gutentags#inprogress()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-gutentags/autoload/gutentags.vim:644
Called 39 times
Total time:   0.001359
 Self time:   0.001032

count  total (s)   self (s)
                                " Does this buffer have gutentags enabled?
   39              0.000071     if !exists('b:gutentags_files')
                                    return []
   39              0.000013     endif
                            
                                " Find any module that has a job in progress for any of this buffer's
                                " tags files.
   39              0.000053     let l:modules_in_progress = []
   78              0.000169     for [module, tags_file] in items(b:gutentags_files)
   39   0.000572   0.000246         let l:jobidx = gutentags#find_job_index_by_tags_file(module, tags_file)
   39              0.000036         if l:jobidx >= 0
                                        call add(l:modules_in_progress, module)
   39              0.000014         endif
   78              0.000034     endfor
   39              0.000036     return l:modules_in_progress

FUNCTION  sy#repo#get_diff()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:73
Called 4 times
Total time:   0.004582
 Self time:   0.004114

count  total (s)   self (s)
    4   0.000075   0.000020   call sy#verbose('sy#repo#get_diff()', a:vcs)
                            
    4              0.000013   let job_id = getbufvar(a:bufnr, 'sy_job_id_'.a:vcs)
                            
    4              0.000013   if getbufvar(a:bufnr, '&modified')
                                let [cmd, options] = s:initialize_buffer_job(a:bufnr, a:vcs)
                                let options.difftool = 'diff'
    4              0.000002   else
    4   0.000441   0.000028     let [cmd, options] = s:initialize_job(a:bufnr, a:vcs)
    4              0.000008     let options.difftool = a:vcs
    4              0.000002   endif
                            
    4              0.000006   let options.func = a:func
                            
    4              0.000007   if has('nvim')
    4              0.000003     if job_id
                                  silent! call jobstop(job_id)
    4              0.000002     endif
    4              0.003836     let job_id = jobstart(cmd, extend(options, { 'cwd':       getbufvar(a:bufnr, 'sy').info.dir, 'on_stdout': function('s:callback_nvim_stdout'), 'on_exit':   function('s:callback_nvim_exit'), }))
    4              0.000034     call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              elseif has('patch-8.0.902')
                                if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
                                endif
                                let opts = { 'cwd':      getbufvar(a:bufnr, 'sy').info.dir, 'in_io':    'null', 'out_cb':   function('s:callback_vim_stdout', options), 'close_cb': function('s:callback_vim_close', options), }
                                let job_id = job_start(cmd, opts)
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
    4              0.000002   endif

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:174
Called 2 times
Total time:   0.005320
 Self time:   0.000111

count  total (s)   self (s)
    2   0.000078   0.000012   if airline#util#stl_disabled(winnr())
                                return
    2              0.000001   endif
    3              0.000005   for nr in a:range
    1   0.000045   0.000008     if airline#util#stl_disabled(nr)
                                  continue
    1              0.000001     endif
    1              0.000003     call setwinvar(nr, 'airline_active', 0)
    1              0.000006     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    1              0.000003     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
    1              0.000000     endif
    1   0.005125   0.000018     call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
    3              0.000004   endfor

FUNCTION  <SNR>96_get_syn()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:44
Called 952 times
Total time:   0.014824
 Self time:   0.014824

count  total (s)   self (s)
  952              0.000890     let color = ''
  952              0.001416     if hlexists(a:group)
  936              0.003345       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
  952              0.000389     endif
  952              0.001741     if empty(color) || color == -1
                                  " should always exist
   16              0.000051       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
   16              0.000025       if empty(color) || color == -1
                                    let color = 'NONE'
   16              0.000005       endif
  952              0.000343     endif
  952              0.000742     return color

FUNCTION  <SNR>98_sh_autocmd_handler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:353
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000005   if exists('#airline')
    2              0.000004     unlet! b:airline_head b:airline_do_mq_check
    2              0.000001   endif

FUNCTION  <SNR>81_Tree()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:339
Called 39 times
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
   39              0.000043   let dir = a:path
   39              0.000102   if dir =~# '/\.git$'
   39              0.000102     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let ext_wtc_pat = 'v:val =~# "^\\s*worktreeConfig *= *\\%(true\\|yes\\|on\\|1\\) *$"'
                                let config = s:ReadFile(dir . '/config', 10)
                                if len(config)
                                  let ext_wtc_config = filter(copy(config), ext_wtc_pat)
                                  if len(ext_wtc_config) == 1 && filereadable(dir . '/config.worktree')
                                     let config += s:ReadFile(dir . '/config.worktree', 10)
                                  endif
                                else
                                  let worktree = fnamemodify(FugitiveVimPath(get(s:ReadFile(dir . '/gitdir', 1), '0', '')), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                  if len(filter(s:ReadFile(FugitiveCommonDir(dir) . '/config', 10), ext_wtc_pat))
                                    let config = s:ReadFile(dir . '/config.worktree', 10)
                                  endif
                                endif
                                if len(config)
                                  let wt_config = filter(copy(config), 'v:val =~# "^\\s*worktree *="')
                                  if len(wt_config)
                                    let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                  elseif !exists('worktree')
                                    call filter(config,'v:val =~# "^\\s*bare *= *true *$"')
                                    if empty(config)
                                      let s:worktree_for_dir[dir] = 0
                                    endif
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>125_get_base_cmd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:503
Called 4 times
Total time:   0.000258
 Self time:   0.000106

count  total (s)   self (s)
    4              0.000010   let cmd = a:vcs_cmds[a:vcs]
    4   0.000150   0.000045   let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:bufnr, a:vcs))
    4   0.000048   0.000023   let cmd = s:replace(cmd, '%d', s:difftool)
    4   0.000043   0.000021   let cmd = s:replace(cmd, '%n', s:devnull)
    4              0.000004   return cmd

FUNCTION  <SNR>136_Tree()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:489
Called 39 times
Total time:   0.002244
 Self time:   0.000189

count  total (s)   self (s)
   39   0.002229   0.000174   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  FugitiveHead()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:250
Called 39 times
Total time:   0.018711
 Self time:   0.000946

count  total (s)   self (s)
   39              0.000218   if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
   39              0.000032   elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
   39              0.000013   else
   39   0.001319   0.000144     let dir = FugitiveGitDir()
   39              0.000071     let arg = get(a:, 1, 0)
   39              0.000016   endif
   39              0.000041   if empty(dir)
                                return ''
   39              0.000013   endif
   39   0.016760   0.000170   return fugitive#Head(arg, dir)

FUNCTION  <SNR>96_get_array()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:60
Called 238 times
Total time:   0.001178
 Self time:   0.001178

count  total (s)   self (s)
  238              0.001108     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  airline#parts#ffenc()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:108
Called 2 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000006   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
    2              0.000007   let bomb     = &bomb ? '[BOM]' : ''
    2              0.000014   let noeolf   = &eol ? '' : '[!EOL]'
    2              0.000014   let ff       = strlen(&ff) ? '['.&ff.']' : ''
    2              0.000010   if expected is# &fenc.bomb.noeolf.ff
                                return ''
    2              0.000001   else
    2              0.000008     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  FugitiveCommonDir()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:287
Called 39 times
Total time:   0.001733
 Self time:   0.000385

count  total (s)   self (s)
   39   0.001503   0.000154   let dir = FugitiveGitDir(a:0 ? a:1 : -1)
   39              0.000043   if empty(dir)
                                return ''
   39              0.000013   endif
   39              0.000072   if has_key(s:commondirs, dir)
   39              0.000054     return s:commondirs[dir]
                              endif
                              if getfsize(dir . '/HEAD') >= 10
                                let cdir = get(s:ReadFile(dir . '/commondir', 1), 0, '')
                                if cdir =~# '^/\|^\a:/'
                                  let s:commondirs[dir] = s:Slash(FugitiveVimPath(cdir))
                                elseif len(cdir)
                                  let s:commondirs[dir] = simplify(dir . '/' . cdir)
                                else
                                  let s:commondirs[dir] = dir
                                endif
                              else
                                let s:commondirs[dir] = dir
                              endif
                              return s:commondirs[dir]

FUNCTION  <SNR>136_GitDir()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:481
Called 78 times
Total time:   0.003231
 Self time:   0.000367

count  total (s)   self (s)
   78   0.003211   0.000347   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/hunks.vim:69
Called 39 times
Total time:   0.001378
 Self time:   0.000849

count  total (s)   self (s)
   39              0.000142   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
   39              0.000012   endif
   39   0.000741   0.000212   return {b:source_func}()

FUNCTION  <SNR>98_update_branch()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:180
Called 39 times
Total time:   0.023181
 Self time:   0.001365

count  total (s)   self (s)
  117              0.000157   for vcs in keys(s:vcs_config)
   78   0.022280   0.000465     call {s:vcs_config[vcs].update_branch}()
   78              0.000208     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
   78              0.000028     endif
  117              0.000056   endfor

FUNCTION  <SNR>81_Slash()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:512
Called 159 times
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
  159              0.000125     return a:path

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-devicons/plugin/webdevicons.vim:503
Called 64 times
Total time:   0.007686
 Self time:   0.007347

count  total (s)   self (s)
   64              0.000056   if a:0 == 0
   39              0.000143     let fileNodeExtension = !empty(expand('%:e')) ? expand('%:e') : &filetype
   39              0.000060     let fileNode = expand('%:t')
   39              0.000037     let isDirectory = 0
   25              0.000010   else
   25              0.000053     let fileNodeExtension = fnamemodify(a:1, ':e')
   25              0.000046     let fileNode = fnamemodify(a:1, ':t')
   25              0.000019     if a:0 > 1
                                  let isDirectory = a:2
   25              0.000020     else
   25              0.000024       let isDirectory = 0
   25              0.000009     endif
   64              0.000021   endif
                            
   64              0.000089   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
   64              0.000111     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   64              0.000129     let fileNodeExtension = tolower(fileNodeExtension)
   64              0.000098     let fileNode = tolower(fileNode)
                            
  640              0.001094     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
  576              0.002053       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
  576              0.000180       endif
  640              0.000219     endfor
                            
   64              0.000106     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   64              0.000152       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
   64              0.000315       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
   64              0.000052       elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   64              0.000023       endif
   64              0.000023     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   64              0.000022   endif
                            
   64   0.000687   0.000348   let artifactFix = s:DevIconsGetArtifactFix()
                            
   64              0.000077   return symbol . artifactFix
                            

FUNCTION  airline#update_tabline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:291
Called 8 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    8              0.000016   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
    8              0.000003   endif

FUNCTION  airline#parts#get()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:49
Called 78 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
   78              0.000211   return get(s:parts, a:key, {})

FUNCTION  sy#highlight#line_disable()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/highlight.vim:42
Called 4 times
Total time:   0.000236
 Self time:   0.000139

count  total (s)   self (s)
    4   0.000065   0.000037   execute 'sign define SignifyAdd text='. s:sign_add ' texthl=SignifySignAdd linehl= '. sy#util#numhl('SignifySignAdd')
    4   0.000052   0.000028   execute 'sign define SignifyChange text='. s:sign_change ' texthl=SignifySignChange linehl= '. sy#util#numhl('SignifySignChange')
    4   0.000057   0.000033   execute 'sign define SignifyChangeDelete text='. s:sign_change_delete ' texthl=SignifySignChangeDelete linehl= '. sy#util#numhl('SignifySignChangeDelete')
    4   0.000052   0.000030   execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line ' texthl=SignifySignDeleteFirstLine linehl= '. sy#util#numhl('SignifySignDeleteFirstLine')
    4              0.000005   let g:signify_line_highlight = 0

FUNCTION  airline#parts#paste()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:63
Called 39 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
   39              0.000080   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:144
Called 2 times
Total time:   0.025654
 Self time:   0.000151

count  total (s)   self (s)
    2   0.000111   0.000025   if airline#util#stl_disabled(winnr()) || airline#util#is_popup_window(winnr())
                                return
    2              0.000001   endif
                              " TODO: need to ignore popup windows here as well?
    2              0.000019   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    2   0.005336   0.000016   call airline#update_statusline_inactive(range)
                            
    2              0.000004   unlet! w:airline_render_left w:airline_render_right
    2              0.000028   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    2              0.000003   let w:airline_active = 1
    2              0.000013   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    2   0.020130   0.000033   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:164
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000021   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    2              0.000002   endif

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/hunks.vim:88
Called 39 times
Total time:   0.006322
 Self time:   0.003664

count  total (s)   self (s)
   39              0.000070   if !get(w:, 'airline_active', 0)
                                return ''
   39              0.000013   endif
                              " Cache values, so that it isn't called too often
   39   0.001100   0.000861   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   39              0.000013   endif
   39   0.001561   0.000184   let hunks = airline#extensions#hunks#get_raw_hunks()
   39              0.000033   let string = ''
   39   0.000326   0.000216   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   39              0.000045   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
  156              0.000140     for i in [0, 1, 2]
  117   0.001215   0.000554       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  117              0.000429         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  117              0.000043       endif
  156              0.000072     endfor
   39              0.000014   endif
   39   0.000325   0.000264   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
   39              0.000014   endif
                            
   39              0.000051   let b:airline_hunks = string
   39              0.000051   let b:airline_changenr = b:changedtick
   39   0.000342   0.000133   let s:airline_winwidth = airline#util#winwidth()
   39              0.000029   return string

FUNCTION  fugitive#Head()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:918
Called 39 times
Total time:   0.016590
 Self time:   0.001768

count  total (s)   self (s)
   39              0.000089   let dir = a:0 > 1 ? a:2 : s:Dir()
   39              0.000041   if empty(dir)
                                return ''
   39              0.000012   endif
   39   0.015014   0.000193   let file = fugitive#Find('.git/HEAD', dir)
   39              0.000415   let ftime = getftime(file)
   39              0.000033   if ftime == -1
                                return ''
   39              0.000129   elseif ftime != get(s:head_cache, file, [-1])[0]
    3              0.000067     let s:head_cache[file] = [ftime, readfile(file)[0]]
   39              0.000013   endif
   39              0.000074   let head = s:head_cache[file][1]
   39              0.000053   let len = a:0 ? a:1 : 0
   39              0.000102   if head =~# '^ref: '
   39              0.000032     if len < 0
                                  return strpart(head, 5)
   39              0.000015     else
   39              0.000283       return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                                endif
                              elseif head =~# '^\x\{40,\}$'
                                return len < 0 ? head : strpart(head, 0, len)
                              else
                                return ''
                              endif

FUNCTION  sy#util#execute()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/util.vim:107
Called 4 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    4              0.000006   let lang = v:lang
    4              0.000011   redir => output
    4              0.000019     silent! execute a:cmd
    4              0.000005   redir END
    4              0.000064   silent! execute 'language message' lang
    4              0.000004   return output

FUNCTION  <SNR>136_DirUrlPrefix()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:485
Called 39 times
Total time:   0.001708
 Self time:   0.000199

count  total (s)   self (s)
   39   0.001699   0.000190   return 'fugitive://' . call('s:GitDir', a:000) . '//'

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:130
Called 14 times
Total time:   0.004776
 Self time:   0.000395

count  total (s)   self (s)
   14              0.000028   if a:group1 == a:group2
                                return 0
   14              0.000007   endif
   14   0.002352   0.000117   let color1 = airline#highlighter#get_highlight(a:group1)
   14   0.002268   0.000121   let color2 = airline#highlighter#get_highlight(a:group2)
   14              0.000092   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  airline#highlighter#exec()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:219
Called 110 times
Total time:   0.021854
 Self time:   0.007233

count  total (s)   self (s)
  110              0.000114     if pumvisible()
                                  return
  110              0.000038     endif
  110              0.000118     let colors = a:colors
  110              0.000142     if len(colors) == 4
   50              0.000076       call add(colors, '')
  110              0.000040     endif
                                " colors should always be string values
  110              0.001555     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
  110              0.000091     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  110              0.000042     endif
  110   0.012694   0.000606     let old_hi = airline#highlighter#get_highlight(a:group)
  110              0.000643     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  110   0.002221   0.000495     let colors = s:CheckDefined(colors)
  110   0.001384   0.000577     if old_hi != new_hi || !s:hl_group_exists(a:group)
                                  let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
                                  try
                                    exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
                                  endtry
                                  if has_key(s:hl_groups, a:group)
                                    let s:hl_groups[a:group] = colors
                                  endif
  110              0.000036     endif

FUNCTION  sy#repo#get_stats()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:234
Called 39 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
   39              0.000135   let sy = getbufvar(a:0 ? a:1 : bufnr(''), 'sy')
   39              0.000091   return empty(sy) ? [-1, -1, -1] : sy.stats

FUNCTION  <SNR>97_get_hunks_signify()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/hunks.vim:29
Called 39 times
Total time:   0.000529
 Self time:   0.000285

count  total (s)   self (s)
   39   0.000432   0.000187   let hunks = sy#repo#get_stats()
   39              0.000049   if hunks[0] >= 0
   39              0.000028     return hunks
                              endif
                              return []

FUNCTION  <SNR>125_get_vcs_path()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:496
Called 4 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    4              0.000058   return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)') ? getbufvar(a:bufnr, 'sy').info.file : getbufvar(a:bufnr, 'sy').info.path

FUNCTION  13()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:17
Called 20 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
   20              0.000067   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>79_isDarwin()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-devicons/plugin/webdevicons.vim:131
Called 39 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
   39              0.000059   if exists('s:is_darwin')
   39              0.000031     return s:is_darwin
                              endif
                            
                              if exists('g:WebDevIconsOS')
                                let s:is_darwin = g:WebDevIconsOS ==? 'Darwin'
                                return s:is_darwin
                              endif
                            
                              if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
                              endif
                            
                              if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
                              endif
                            
                              if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
                              else
                                let s:is_darwin = 0
                              endif
                            
                              return s:is_darwin

FUNCTION  airline#util#is_popup_window()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:207
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                               " Keep the statusline active if it's a popup window
    2              0.000005    if exists('*win_gettype')
    2              0.000008      return win_gettype(a:winnr) ==# 'popup' || win_gettype(a:winnr) ==# 'autocmd'
                               else
                                  return getwinvar(a:winnr, '&buftype', '') ==# 'popup'
                              endif

FUNCTION  sy#sign#process_diff()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:55
Called 4 times
Total time:   0.000921
 Self time:   0.000652

count  total (s)   self (s)
    4              0.000008   let a:sy.signtable             = {}
    4              0.000005   let a:sy.hunks                 = []
    4              0.000011   let [added, modified, deleted] = [0, 0, 0]
                            
    4   0.000252   0.000019   call sy#sign#get_current_signs(a:sy)
                            
                              " Determine where we have to put our signs.
    4              0.000022   for line in filter(a:diff, 'v:val =~ "^@@ "')
                                let a:sy.lines = []
                                let ids        = []
                            
                                let [old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(line)
                            
                                " Workaround for non-conventional diff output in older Fossil versions:
                                " https://fossil-scm.org/forum/forumpost/834ce0f1e1
                                " Fixed as of: https://fossil-scm.org/index.html/info/7fd2a3652ea7368a
                                if a:vcs == 'fossil' && new_line == 0
                                  let new_line = old_line - 1 - deleted
                                endif
                            
                                " Pure add:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
                                if old_count == 0 && new_count > 0
                                  let added += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                  endwhile
                            
                                " Pure delete
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
                                elseif old_count > 0 && new_count == 0
                                  if s:external_sign_present(a:sy, new_line) | continue | endif
                                  let deleted += old_count
                                  if new_line == 0
                                    call add(ids, s:add_sign(a:sy, 1, 'SignifyRemoveFirstLine'))
                                  elseif s:sign_show_count
                                    if old_count > 99
                                      let text = s:sign_delete . '>'
                                    elseif old_count < 2
                                      let text = s:sign_delete
                                    else
                                      let text = s:sign_delete . old_count
                                    endif
                                    while strwidth(text) > 2
                                      let text = substitute(text, '.', '', '')
                                    endwhile
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDelete'. old_count, text))
                                  else
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDeleteMore', s:sign_delete))
                                  endif
                                " All lines are modified.
                                elseif old_count > 0 && new_count > 0 && old_count == new_count
                                  let modified += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
                                " Some lines are modified and some new lines are added.
                                elseif old_count > 0 && new_count > 0 && old_count < new_count
                                  let modified += old_count
                                  let added += new_count - old_count
                                  let offset = 0
                                  while offset < old_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                  endwhile
                                " Some lines are modified and some lines are deleted.
                                elseif old_count > 0 && new_count > 0 && old_count > new_count
                                  let modified += new_count
                                  let deleted_count = old_count - new_count
                                  let deleted += deleted_count
                            
                                  let prev_line_available = new_line > 1 && !get(a:sy.signtable, new_line - 1, 0)
                                  if prev_line_available
                                    if s:sign_show_count
                                      if deleted_count > 99
                                        let text = s:sign_delete . '>'
                                      elseif deleted_count < 2
                                        let text = s:sign_delete
                                      else
                                        let text = s:sign_delete . deleted_count
                                      endif
                                      while strwidth(text) > 2
                                        let text = substitute(text, '.', '', '')
                                      endwhile
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDelete'. deleted_count, text))
                                    else
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDeleteMore', s:sign_delete))
                                    endif
                                  endif
                            
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    if !prev_line_available && offset == 0
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChangeDelete'))
                                    else
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                    endif
                                    let offset += 1
                                  endwhile
                                endif
                            
                                if !empty(ids)
                                  call add(a:sy.hunks, { 'ids'  : ids, 'start': a:sy.lines[0], 'end'  : a:sy.lines[-1] })
                                endif
    4              0.000009   endfor
                            
                              " Remove obsoleted signs.
    4              0.000014   for line in filter(keys(a:sy.internal), '!has_key(a:sy.signtable, v:val)')
                                execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
    4              0.000002   endfor
                            
    4              0.000010   if empty(a:sy.updated_by) && empty(a:sy.hunks)
    4   0.000060   0.000023     call sy#verbose('Successful exit value, but no diff. Keep VCS for time being.', a:vcs)
    4              0.000002     return
                              endif
                            
                              call sy#verbose('Signs updated.', a:vcs)
                              let a:sy.updated_by = a:vcs
                              if len(a:sy.vcs) > 1
                                call sy#verbose('Disable all other VCS.', a:vcs)
                                let a:sy.vcs = [a:vcs]
                              endif
                            
                              let a:sy.stats = [added, modified, deleted]

FUNCTION  sy#util#refresh_windows()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/util.vim:26
Called 2 times
Total time:   0.003481
 Self time:   0.000162

count  total (s)   self (s)
    2              0.000019   if exists('*win_getid')
    2              0.000008     let winid = win_getid()
                              else
                                let winnr = winnr()
    2              0.000001   endif
                            
    2              0.000008   if !get(g:, 'signify_cmdwin_active')
    5              0.000014     for bufnr in tabpagebuflist()
    3   0.000069   0.000038       if sy#buffer_is_active(bufnr)
    2   0.003308   0.000020         call sy#start({'bufnr': bufnr})
    3              0.000002       endif
    5              0.000003     endfor
    2              0.000001   endif
                            
    2              0.000006   if exists('winid')
    2              0.000010     call win_gotoid(winid)
                              else
                                execute winnr .'wincmd w'
    2              0.000001   endif

FUNCTION  <SNR>98_config_fugitive_branch()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:99
Called 39 times
Total time:   0.019184
 Self time:   0.000473

count  total (s)   self (s)
   39   0.019005   0.000294   let s:vcs_config['git'].branch = exists('*FugitiveHead') ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   39              0.000098   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
   39              0.000015   endif

FUNCTION  <SNR>119_get_seperator()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:155
Called 14 times
Total time:   0.015512
 Self time:   0.000262

count  total (s)   self (s)
   14   0.004884   0.000108   if airline#builder#should_change_group(a:prev_group, a:group)
   14   0.010617   0.000143     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 2 times
Total time:   0.000056
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000055   0.000018   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  airline#parts#spell()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:67
Called 39 times
Total time:   0.000827
 Self time:   0.000827

count  total (s)   self (s)
   39              0.000264   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   39              0.000159   if g:airline_detect_spell && (&spell || (exists('g:airline_spell_check_command') && eval(g:airline_spell_check_command)))
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                elseif !empty(g:airline_symbols.spell)
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   39              0.000013   endif
   39              0.000021   return ''

FUNCTION  <SNR>80_invoke_funcrefs()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:195
Called 3 times
Total time:   0.025203
 Self time:   0.000180

count  total (s)   self (s)
    3   0.000115   0.000020   let builder = airline#builder#new(a:context)
    3   0.003380   0.000041   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    3              0.000003   if err == 1
    3   0.021616   0.000027     let a:context.line = builder.build()
    3              0.000016     let s:contexts[a:context.winnr] = a:context
    3              0.000014     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    3              0.000051     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    3              0.000002   endif

FUNCTION  <SNR>98_update_untracked()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:199
Called 39 times
Total time:   0.002501
 Self time:   0.002101

count  total (s)   self (s)
   39              0.000260   let file = expand("%:p")
   39              0.000165   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   39              0.000014   endif
                            
   39              0.000042   let needs_update = 1
   39              0.000132   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  117              0.000139   for vcs in keys(s:vcs_config)
   78              0.000210     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
   78              0.000028     endif
   78              0.000178     if has_key(s:vcs_config[vcs].untracked, file)
   39              0.000036       let needs_update = 0
   39   0.000629   0.000228       call airline#extensions#branch#update_untracked_config(file, vcs)
   78              0.000027     endif
  117              0.000052   endfor
                            
   39              0.000031   if !needs_update
   39              0.000019     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  sy#buffer_is_active()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:113
Called 3 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    3              0.000010   let bufnr = a:0 ? a:1 : bufnr('')
    3              0.000017   return !empty(getbufvar(bufnr, 'sy'))

FUNCTION  <SNR>136_ExpireStatus()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:4159
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000005   if a:bufnr is# -2 || a:bufnr is# 0
    2              0.000007     let s:head_cache = {}
    2              0.000007     let s:last_time = reltime()
    2              0.000003     return ''
                              endif
                              let dir = s:Dir(a:bufnr)
                              if len(dir)
                                let s:last_times[s:cpath(dir)] = reltime()
                                if has_key(s:head_cache, dir)
                                  call remove(s:head_cache, dir)
                                endif
                              endif
                              return ''

FUNCTION  airline#parts#crypt()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:59
Called 39 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
   39              0.000219   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:34
Called 25 times
Total time:   0.000465
 Self time:   0.000465

count  total (s)   self (s)
   25              0.000074     let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
   25              0.000060     let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
                            
   25              0.000082     let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
   25              0.000105     let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   25              0.000051     if getbufvar(a:bufnr, '&modified') == 1
                                  let _ .= g:airline_symbols.modified
   25              0.000009     endif
   25              0.000018     return _

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:246
Called 39 times
Total time:   0.026917
 Self time:   0.000948

count  total (s)   self (s)
   39              0.000070   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
   39              0.000014   endif
                            
   39   0.023331   0.000150   call s:update_branch()
   39   0.002686   0.000185   call s:update_untracked()
                            
   39              0.000105   if exists('b:airline_head') && !empty(b:airline_head)
   36              0.000032     return b:airline_head
    3              0.000001   endif
                            
    3              0.000004   let b:airline_head = ''
    3              0.000011   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    3              0.000003   let heads = []
    9              0.000008   for vcs in vcs_priority
    6              0.000012     if !empty(b:buffer_vcs_config[vcs].branch)
    3              0.000006       let heads += [vcs]
    6              0.000002     endif
    9              0.000004   endfor
                            
    6              0.000005   for vcs in heads
    3              0.000004     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
    3              0.000001     endif
    3              0.000004     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
    3              0.000001     endif
    3   0.000321   0.000034     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    3              0.000007     let additional = b:buffer_vcs_config[vcs].untracked
    3              0.000011     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
    3              0.000001     endif
    3              0.000005     let b:airline_head .= additional
    6              0.000003   endfor
                            
    3              0.000003   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
    3              0.000001   endif
                            
    3              0.000003   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
    3              0.000001   endif
                            
    3              0.000006   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  'â€¦' : '.')
                                endif
    3              0.000001   endif
                            
    3              0.000003   return b:airline_head

FUNCTION  WebDevIconsGetFileFormatSymbol()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-devicons/plugin/webdevicons.vim:565
Called 39 times
Total time:   0.001352
 Self time:   0.000925

count  total (s)   self (s)
   39              0.000041   let fileformat = ''
   39              0.000034   let bomb = ''
                            
   39              0.000064   if (&bomb && g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol !=? '')
                                let bomb = g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol . ' '
   39              0.000012   endif
                            
   39              0.000039   if &fileformat ==? 'dos'
                                let fileformat = 'îœ'
   39              0.000037   elseif &fileformat ==? 'unix'
   39   0.000478   0.000263     let fileformat = s:isDarwin() ? 'îœ‘' : s:getDistro()
                              elseif &fileformat ==? 'mac'
                                let fileformat = 'îœ‘'
   39              0.000013   endif
                            
   39   0.000371   0.000159   let artifactFix = s:DevIconsGetArtifactFix()
                            
   39              0.000061   return bomb . fileformat . artifactFix

FUNCTION  airline#parts#mode()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:55
Called 39 times
Total time:   0.001048
 Self time:   0.000243

count  total (s)   self (s)
   39   0.001029   0.000224   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#gutentags#status()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/gutentags.vim:11
Called 39 times
Total time:   0.001856
 Self time:   0.000228

count  total (s)   self (s)
   39   0.001773   0.000146   let msg = gutentags#statusline()
   39              0.000066   return empty(msg) ? '' :  'Gen. ' . msg

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000004   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    2              0.000001   endif

FUNCTION  <SNR>79_CursorHoldUpdate()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-devicons/plugin/webdevicons.vim:409
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000013   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    2              0.000002   endif
                            
    2              0.000011   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    2              0.000002     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  <SNR>125_wrap_cmd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:471
Called 4 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    4              0.000010   if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell|pwsh)' ? a:cmd : ['sh', '-c', a:cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', a:cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, a:cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, a:cmd, &shellxquote])
                                  endif
                                endif
    4              0.000002   else
    4              0.000008     let cmd = ['sh', '-c', a:cmd]
    4              0.000002   endif
    4              0.000019   let options = { 'stdoutbuf': [''], 'vcs': a:vcs, 'bufnr': a:bufnr, }
    4              0.000007   return [cmd, options]

FUNCTION  <SNR>123_get_path()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:161
Called 4 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    4              0.000095   let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
    4              0.000009   if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
    4              0.000002   endif
    4              0.000004   return path

FUNCTION  sy#sign#set_signs()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:235
Called 4 times
Total time:   0.001339
 Self time:   0.000132

count  total (s)   self (s)
    4   0.000067   0.000017   call sy#verbose('sy#sign#set_signs()', a:vcs)
                            
    4              0.000008   if a:sy.stats == [-1, -1, -1]
                                let a:sy.stats = [0, 0, 0]
    4              0.000001   endif
                            
    4              0.000004   if empty(a:diff)
                                call sy#verbose('No changes found.', a:vcs)
                                let a:sy.stats = [0, 0, 0]
                                call sy#sign#remove_all_signs(a:sy.buffer)
                                return
    4              0.000001   endif
                            
    4              0.000007   if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
    4              0.000002   else
    4   0.000253   0.000017     call sy#highlight#line_disable()
    4              0.000002   endif
                            
    4   0.000941   0.000020   call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
    4              0.000015   if exists('#User#Signify')
                                doautocmd <nomodeline> User Signify
    4              0.000001   endif

FUNCTION  fugitive#Find()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:1706
Called 39 times
Total time:   0.014821
 Self time:   0.007177

count  total (s)   self (s)
   39              0.000079   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
   39              0.000123   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
   39              0.000014   endif
   39   0.000222   0.000176   let rev = s:Slash(a:object)
   39              0.000295   if rev =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
   39              0.000159   elseif rev =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
   39              0.000014   endif
   39   0.001925   0.000203   let dir = call('s:GitDir', a:000)
   39              0.000043   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs\%(\.\.\=$\|\.\.\=/.*\|/.*\|\w:/.*\)')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return ''
                                endif
   39              0.000012   endif
   39   0.002397   0.000153   let tree = s:Tree(dir)
   39   0.001894   0.000185   let urlprefix = s:DirUrlPrefix(dir)
   39              0.000086   let base = len(tree) ? tree : urlprefix . '0'
   39              0.000035   if rev ==# '.git'
                                let f = len(tree) && len(getftype(tree . '/.git')) ? tree . '/.git' : dir
   39              0.000092   elseif rev =~# '^\.git/'
   39              0.000074     let f = strpart(rev, 5)
   39              0.000050     let fdir = dir . '/'
   39   0.001907   0.000173     let cdir = FugitiveCommonDir(dir) . '/'
   39              0.000101     if f =~# '^\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[2:-1] : fdir . f)
   39              0.000076     elseif f =~# '^\.\.\%(/\|$\)'
                                  let f = base . f[2:-1]
   39              0.000267     elseif cdir !=# fdir && ( f =~# '^\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(fdir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
   39              0.000020     else
   39              0.000094       let f = simplify(fdir . f)
   39              0.000015     endif
                              elseif rev ==# ':/'
                                let f = tree
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = urlprefix . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = urlprefix . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                let fdir = dir . '/'
                                let f = fdir . 'index'
                                if len($GIT_INDEX_FILE)
                                  let index_dir = substitute($GIT_INDEX_FILE, '[^/]\+$', '', '')
                                  if s:cpath(index_dir, fdir)
                                    let f = FugitiveVimPath($GIT_INDEX_FILE)
                                  elseif s:cpath(resolve(FugitiveVimPath(index_dir)), fdir)
                                    let f = resolve(FugitiveVimPath($GIT_INDEX_FILE))
                                  endif
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = urlprefix . '0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) ? "@" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$\|^$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                    if empty(commit) && len(file)
                                      let commit = repeat('0', 40)
                                    endif
                                  endif
                                  if len(commit)
                                    let f = urlprefix . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
   39              0.000020   endif
   39   0.000327   0.000137   return FugitiveVimPath(f)

FUNCTION  <SNR>98_display_git_branch()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:122
Called 3 times
Total time:   0.000283
 Self time:   0.000122

count  total (s)   self (s)
                              " disable FocusGained autocommand, might cause loops because system() causes
                              " a refresh, which causes a system() command again #2029
    3   0.000154   0.000027   call airline#util#ignore_next_focusgain()
    3              0.000009   let name = b:buffer_vcs_config['git'].branch
    3              0.000002   try
    3   0.000063   0.000028     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
    3              0.000005     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
    3              0.000004     elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
    3              0.000001     endif
                              catch
    3              0.000002   endtry
    3              0.000002   return name

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount.vim:93
Called 2 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    2              0.000035   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    2              0.000005   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    2              0.000003   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
                                let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    2              0.000001   endif
                            
    2              0.000005   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    2              0.000001   endif

FUNCTION  <SNR>125_check_diff_git()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:163
Called 4 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    4              0.000010   return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  <SNR>125_callback_nvim_exit()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:22
Called 4 times
Total time:   0.001725
 Self time:   0.000033

count  total (s)   self (s)
    4   0.001723   0.000030   return s:handle_diff(self, a:exitval)

FUNCTION  <SNR>98_update_git_branch()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:87
Called 39 times
Total time:   0.020276
 Self time:   0.000669

count  total (s)   self (s)
   39   0.000392   0.000179   call airline#util#ignore_next_focusgain()
   39   0.000349   0.000138   if airline#util#has_fugitive()
   39   0.019336   0.000152     call s:config_fugitive_branch()
                              elseif airline#util#has_gina()
                                call s:config_gina_branch()
                              else
                                let s:vcs_config['git'].branch = ''
                                return
   39              0.000014   endif

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/tabline/buffers.vim:51
Called 25 times
Total time:   0.003774
 Self time:   0.000492

count  total (s)   self (s)
   25              0.000024   try
   25   0.003422   0.000140     call <sid>map_keys()
                              catch
                                " no-op
   25              0.000017   endtry
   25              0.000055   let cur = bufnr('%')
   25              0.000063   if cur == s:current_bufnr && &columns == s:column_width
   25              0.000096     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
   25              0.000033       return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                              let tab_bufs = tabpagebuflist(tabpagenr())
                              let show_buf_label_first = 0
                            
                              if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
                              if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
                              endif
                            
                              let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
                              let b.overflow_group = 'airline_tabhid'
                              let b.buffers = airline#extensions#tabline#buflist#list()
                              if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
                              function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
                              if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
                              function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
                              let current_buffer = max([index(b.buffers, cur), 0])
                              let last_buffer = len(b.buffers) - 1
                              call b.insert_titles(current_buffer, 0, last_buffer)
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                              if !show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 1)
                              endif
                            
                              call airline#extensions#tabline#add_tab_label(b)
                            
                              let s:current_bufnr = cur
                              let s:column_width = &columns
                              let s:current_tabline = b.build()
                              let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
                              return s:current_tabline

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:54
Called 2 times
Total time:   0.000037
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000029   0.000015   call <sid>check_defined_section(a:name)
    2              0.000007   let w:airline_section_{a:name} .= a:value

FUNCTION  airline#statusline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:208
Called 39 times
Total time:   0.000476
 Self time:   0.000476

count  total (s)   self (s)
   39              0.000200   if has_key(s:contexts, a:winnr)
   39              0.000237     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>98_update_hg_branch()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:145
Called 39 times
Total time:   0.001539
 Self time:   0.001359

count  total (s)   self (s)
   39   0.000345   0.000165   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   39              0.000017   else
   39              0.000060     let s:vcs_config['mercurial'].branch = ''
   39              0.000015   endif

FUNCTION  airline#extensions#apply()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:72
Called 3 times
Total time:   0.000345
 Self time:   0.000193

count  total (s)   self (s)
    3              0.000014   let filetype_overrides = get(s:, 'filetype_overrides', {})
    3              0.000020   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    3   0.000175   0.000023   if s:is_excluded_window()
                                return -1
    3              0.000001   endif
                            
    3              0.000005   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    3              0.000001   endif
                            
    3              0.000010   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    3              0.000001   endif
                            
    3              0.000024   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    3              0.000001   endif
                            
    3              0.000004   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    3              0.000001   endif
                            
    3              0.000010   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    3              0.000002   endfor

FUNCTION  <SNR>107_map_keys()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/tabline/buffers.vim:195
Called 25 times
Total time:   0.003282
 Self time:   0.003282

count  total (s)   self (s)
   25              0.000076   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   25              0.000023   if bidx_mode > 0
   25              0.000018     if bidx_mode == 1
  275              0.000227       for i in range(1, 10)
  250              0.002266         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i%10, i-1)
  275              0.000113       endfor
                                else
                                  let start_idx = bidx_mode == 2 ? 11 : 1
                                  for i in range(start_idx, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%02d :call <SID>select_tab(%d)<CR>', i, i-start_idx)
                                  endfor
   25              0.000010     endif
   25              0.000153     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   25              0.000120     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
   25              0.000010   endif

FUNCTION  <SNR>73_airline_refresh()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/plugin/airline.vim:216
Called 2 times
Total time:   0.025965
 Self time:   0.000103

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    2              0.000008   let fast=!empty(get(a:000, 0, 0))
    2              0.000007   if !exists("#airline")
                                " disabled
                                return
    2              0.000001   endif
    2   0.000127   0.000012   call airline#util#doautocmd('AirlineBeforeRefresh')
    2   0.000095   0.000013   call airline#highlighter#reset_hlcache()
    2              0.000003   if !fast
                                call airline#load_theme()
    2              0.000001   endif
    2   0.025684   0.000031   call airline#update_statusline()
    2   0.000029   0.000017   call airline#update_tabline()

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:158
Called 39 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
   39              0.000066   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
   39              0.000014   endif
   39              0.000032   return s:has_lawrencium

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:68
Called 238 times
Total time:   0.028287
 Self time:   0.012286

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
  238              0.000948     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  238              0.000710     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  238              0.000099     else
  238   0.005102   0.001227       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  238   0.004836   0.001176       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  238   0.004820   0.001160       let guifg = s:get_syn(a:group, 'fg', 'gui')
  238   0.004775   0.001146       let guibg = s:get_syn(a:group, 'bg', 'gui')
  238              0.000739       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  238              0.000178       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  238              0.000103       else
  238   0.002851   0.001674         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  238              0.000106       endif
  238              0.000093     endif
  238              0.000502     let s:hl_groups[a:group] = res
  238              0.000178     return res

FUNCTION  <SNR>136_can_diffoff()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/autoload/fugitive.vim:6302
Called 7 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    7              0.000054   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  airline#util#shorten()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:28
Called 117 times
Total time:   0.002269
 Self time:   0.001511

count  total (s)   self (s)
  117   0.001373   0.000616   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
  117              0.000037   else
  117              0.000092     return a:text
                              endif

FUNCTION  <SNR>91_is_excluded_window()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:112
Called 3 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
    3              0.000008   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    3              0.000003   endfor
                            
   12              0.000016   for matchw in g:airline_exclude_filenames
    9              0.000068     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
    9              0.000004     endif
   12              0.000007   endfor
                            
    3              0.000005   if g:airline_exclude_preview && &previewwindow
                                return 1
    3              0.000002   endif
                            
    3              0.000003   return 0

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:199
Called 42 times
Total time:   0.000340
 Self time:   0.000340

count  total (s)   self (s)
   42              0.000108   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
   42              0.000016   endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:205
Called 6 times
Total time:   0.001410
 Self time:   0.000144

count  total (s)   self (s)
    6              0.000017     if getbufvar(a:bufnr, '&modified')
                                  let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    6              0.000003     else
    6              0.000043       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    6              0.000002     endif
                            
    6              0.000008     if !empty(colors)
    6   0.001306   0.000040       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    6              0.000002     endif

FUNCTION  <SNR>101_ws_refresh()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/whitespace.vim:186
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000004   if !exists('#airline')
                                " airline disabled
                                return
    2              0.000001   endif
    2              0.000006   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    2              0.000001     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:315
Called 39 times
Total time:   0.029057
 Self time:   0.001271

count  total (s)   self (s)
   39   0.027084   0.000167   let head = airline#extensions#branch#head()
   39   0.000340   0.000218   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   39              0.000112   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   39   0.000927   0.000180   let head = airline#util#shorten(head, winwidth, minwidth)
   39              0.000292   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   39              0.000260   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/nvimlsp.vim:45
Called 39 times
Total time:   0.001911
 Self time:   0.000178

count  total (s)   self (s)
   39   0.001896   0.000163   return airline#extensions#nvimlsp#get('Error')

FUNCTION  sy#util#numhl()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/util.vim:207
Called 16 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   16              0.000013   if !s:use_numhl
                                return ''
   16              0.000005   endif
                            
   16              0.000023   if get(g:, 'signify_number_highlight')
                                return printf('numhl=%s', a:hlgroup)
   16              0.000006   else
   16              0.000010     return 'numhl='
                              endif

FUNCTION  <SNR>125_callback_nvim_stdout()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:16
Called 4 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    4              0.000014   let self.stdoutbuf[-1] .= a:data[0]
    4              0.000013   call extend(self.stdoutbuf, a:data[1:])

FUNCTION  <SNR>120_build_sections()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/default.vim:35
Called 5 times
Total time:   0.001861
 Self time:   0.000278

count  total (s)   self (s)
   26              0.000027   for key in a:keys
   21              0.000062     if (key == 'warning' || key == 'error') && !a:context.active
    2              0.000001       continue
   19              0.000008     endif
   19   0.001705   0.000121     call s:add_section(a:builder, a:context, key)
   24              0.000014   endfor

FUNCTION  <SNR>96_exec_separator()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:189
Called 50 times
Total time:   0.024972
 Self time:   0.001737

count  total (s)   self (s)
   50              0.000063     if pumvisible()
                                  return
   50              0.000018     endif
   50              0.000124     let group = a:from.'_to_'.a:to.a:suffix
   50   0.006583   0.000288     let l:from = airline#themes#get_highlight(a:from.a:suffix)
   50   0.006601   0.000343     let l:to = airline#themes#get_highlight(a:to.a:suffix)
   50              0.000040     if a:inverse
   13              0.000044       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   37              0.000015     else
   37              0.000145       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   50              0.000021     endif
   50              0.000110     let a:dict[group] = colors
   50   0.010988   0.000307     call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>98_format_name()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/branch.vim:77
Called 3 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    3              0.000003     return a:name

FUNCTION  FugitiveParse()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:89
Called 3 times
Total time:   0.000034
 Self time:   0.000031

count  total (s)   self (s)
    3   0.000020   0.000017   let path = s:Slash(a:0 ? a:1 : @%)
    3              0.000008   if path !~# '^fugitive:'
    3              0.000003     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  <SNR>96_hl_group_exists()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:99
Called 110 times
Total time:   0.000806
 Self time:   0.000806

count  total (s)   self (s)
  110              0.000162     if !hlexists(a:group)
                                  return 0
  110              0.000344     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
  110              0.000040     endif
  110              0.000061     return 1

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:64
Called 2 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    2              0.000081     let s:hl_groups = {}

FUNCTION  <SNR>99_sh_autocmd_handler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/fugitiveline.vim:46
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000003   if exists('#airline')
    2              0.000002     unlet! b:fugitive_name
    2              0.000001   endif

FUNCTION  airline#util#getbufvar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:71
Called 5 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    5              0.000014     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:520
Called 39 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
   39              0.000048   return s:loaded_ext

FUNCTION  airline#builder#new()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:229
Called 3 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    3              0.000024   let builder = copy(s:prototype)
    3              0.000007   let builder._context = a:context
    3              0.000006   let builder._sections = []
                            
    3              0.000050   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    3              0.000004   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   39   0.032869   0.003407  airline#check_mode()
   39   0.029057   0.001271  airline#extensions#branch#get_head()
  238   0.028287   0.012286  airline#highlighter#get_highlight()
    6   0.027808   0.003969  airline#highlighter#highlight()
   39   0.026917   0.000948  airline#extensions#branch#head()
    2   0.026024   0.000039  <SNR>73_on_focus_gained()
    2   0.025965   0.000103  <SNR>73_airline_refresh()
    2   0.025654   0.000151  airline#update_statusline()
    3   0.025203   0.000180  <SNR>80_invoke_funcrefs()
   50   0.024972   0.001737  <SNR>96_exec_separator()
   39   0.023181   0.001365  <SNR>98_update_branch()
  110   0.021854   0.007233  airline#highlighter#exec()
    3   0.021589   0.002418  18()
   39   0.020276   0.000669  <SNR>98_update_git_branch()
   39   0.019184   0.000473  <SNR>98_config_fugitive_branch()
   39   0.018711   0.000946  FugitiveHead()
   39   0.016590   0.001768  fugitive#Head()
   14   0.015512   0.000262  <SNR>119_get_seperator()
  952   0.014824             <SNR>96_get_syn()
   39   0.014821   0.007177  fugitive#Find()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  952              0.014824  <SNR>96_get_syn()
  238   0.028287   0.012286  airline#highlighter#get_highlight()
   64   0.007686   0.007347  WebDevIconsGetFileTypeSymbol()
  110   0.021854   0.007233  airline#highlighter#exec()
   39   0.014821   0.007177  fugitive#Find()
  195   0.006797   0.006644  FugitiveGitDir()
   78              0.005009  airline#extensions#nvimlsp#get()
    4   0.004582   0.004114  sy#repo#get_diff()
    6   0.027808   0.003969  airline#highlighter#highlight()
   39   0.004471   0.003754  airline#extensions#whitespace#check()
   39   0.006322   0.003664  airline#extensions#hunks#get_hunks()
   39   0.032869   0.003407  airline#check_mode()
   25              0.003282  <SNR>107_map_keys()
  448              0.002696  airline#util#winwidth()
    3   0.021589   0.002418  18()
   39   0.002501   0.002101  <SNR>98_update_untracked()
  273              0.002000  airline#util#append()
   25   0.002280   0.001815  airline#extensions#tabline#formatters#unique_tail#format()
   39   0.016590   0.001768  fugitive#Head()
   50   0.024972   0.001737  <SNR>96_exec_separator()

